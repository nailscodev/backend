/**
 * @fileoverview CSRF Protection Exception Classes
 * 
 * This file contains custom exception classes for the CSRF protection system.
 * Following Clean Code principles, these exceptions provide clear, specific
 * error information with proper error codes and messages for different
 * CSRF-related failures.
 * 
 * @version 1.0.0
 * @author Professional Development Team
 */

import { HttpException, HttpStatus } from '@nestjs/common';
import { CsrfValidationErrorCode } from '../interfaces/csrf.interfaces';

/**
 * Base exception class for all CSRF-related errors
 * 
 * Provides a common structure for CSRF exceptions with error codes
 * and proper HTTP status mapping.
 */
export abstract class CsrfException extends HttpException {
  /**
   * Specific error code for programmatic handling
   */
  public readonly errorCode: CsrfValidationErrorCode;

  /**
   * Additional context information about the error
   */
  public readonly context?: Record<string, unknown>;

  /**
   * Creates a new CSRF exception
   * 
   * @param message - Human-readable error message
   * @param errorCode - Specific CSRF error code
   * @param httpStatus - HTTP status code to return
   * @param context - Additional error context
   */
  protected constructor(
    message: string,
    errorCode: CsrfValidationErrorCode,
    httpStatus: HttpStatus,
    context?: Record<string, unknown>
  ) {
    super(
      {
        message,
        errorCode,
        timestamp: new Date().toISOString(),
        context: context || {},
      },
      httpStatus
    );
    
    this.errorCode = errorCode;
    this.context = context;
    this.name = this.constructor.name;
  }

  /**
   * Gets a sanitized error response for client consumption
   * 
   * @returns Sanitized error object
   */
  public getErrorResponse(): {
    message: string;
    errorCode: CsrfValidationErrorCode;
    timestamp: string;
  } {
    return {
      message: this.message,
      errorCode: this.errorCode,
      timestamp: new Date().toISOString(),
    };
  }
}

/**
 * Exception thrown when CSRF token is missing from request
 * 
 * This occurs when a protected endpoint is accessed without
 * providing the required CSRF token.
 */
export class CsrfTokenMissingException extends CsrfException {
  constructor(context?: Record<string, unknown>) {
    super(
      'CSRF token is required for this operation. Please include a valid CSRF token in your request.',
      CsrfValidationErrorCode.TOKEN_MISSING,
      HttpStatus.BAD_REQUEST,
      context
    );
  }
}

/**
 * Exception thrown when CSRF token format is invalid
 * 
 * This occurs when the provided token cannot be decrypted
 * or parsed as a valid CSRF token.
 */
export class CsrfTokenMalformedException extends CsrfException {
  constructor(context?: Record<string, unknown>) {
    super(
      'The provided CSRF token is malformed or corrupted. Please obtain a new token.',
      CsrfValidationErrorCode.TOKEN_MALFORMED,
      HttpStatus.BAD_REQUEST,
      context
    );
  }
}

/**
 * Exception thrown when CSRF token has expired
 * 
 * This occurs when the token's expiration time has passed.
 */
export class CsrfTokenExpiredException extends CsrfException {
  constructor(expirationTime?: Date, context?: Record<string, unknown>) {
    const message = expirationTime
      ? `CSRF token expired on ${expirationTime.toISOString()}. Please obtain a new token.`
      : 'CSRF token has expired. Please obtain a new token.';

    super(
      message,
      CsrfValidationErrorCode.TOKEN_EXPIRED,
      HttpStatus.UNAUTHORIZED,
      { ...context, expirationTime: expirationTime?.toISOString() }
    );
  }
}

/**
 * Exception thrown when CSRF token signature is invalid
 * 
 * This occurs when the token has been tampered with or
 * was not generated by this service.
 */
export class CsrfTokenInvalidSignatureException extends CsrfException {
  constructor(context?: Record<string, unknown>) {
    super(
      'CSRF token signature is invalid. The token may have been tampered with.',
      CsrfValidationErrorCode.TOKEN_INVALID_SIGNATURE,
      HttpStatus.FORBIDDEN,
      context
    );
  }
}

/**
 * Exception thrown when session ID doesn't match token
 * 
 * This occurs when the token was generated for a different
 * session than the current request.
 */
export class CsrfSessionMismatchException extends CsrfException {
  constructor(
    expectedSessionId: string,
    actualSessionId: string,
    context?: Record<string, unknown>
  ) {
    super(
      'CSRF token was issued for a different session. Please obtain a new token.',
      CsrfValidationErrorCode.SESSION_MISMATCH,
      HttpStatus.FORBIDDEN,
      {
        ...context,
        expectedSessionId,
        actualSessionId,
      }
    );
  }
}

/**
 * Exception thrown when request origin is not allowed
 * 
 * This occurs when the Origin or Referer headers indicate
 * the request is coming from an unauthorized domain.
 */
export class CsrfOriginForbiddenException extends CsrfException {
  constructor(
    origin: string,
    allowedOrigins: ReadonlyArray<string>,
    context?: Record<string, unknown>
  ) {
    super(
      `Request origin '${origin}' is not allowed. This may indicate a CSRF attack.`,
      CsrfValidationErrorCode.ORIGIN_FORBIDDEN,
      HttpStatus.FORBIDDEN,
      {
        ...context,
        origin,
        allowedOrigins: [...allowedOrigins],
      }
    );
  }
}

/**
 * Exception thrown when a replay attack is detected
 * 
 * This occurs when the same token is used multiple times
 * or other replay attack patterns are detected.
 */
export class CsrfReplayAttackException extends CsrfException {
  constructor(tokenIdentifier?: string, context?: Record<string, unknown>) {
    super(
      'Potential replay attack detected. The CSRF token has already been used.',
      CsrfValidationErrorCode.REPLAY_ATTACK_DETECTED,
      HttpStatus.FORBIDDEN,
      {
        ...context,
        tokenIdentifier,
        detectedAt: new Date().toISOString(),
      }
    );
  }
}

/**
 * Exception thrown when client IP address doesn't match token
 * 
 * This occurs when IP binding is enabled and the request
 * comes from a different IP than the token was issued for.
 */
export class CsrfIpAddressMismatchException extends CsrfException {
  constructor(
    expectedIp: string,
    actualIp: string,
    context?: Record<string, unknown>
  ) {
    super(
      'Request IP address does not match the token. This may indicate session hijacking.',
      CsrfValidationErrorCode.IP_ADDRESS_MISMATCH,
      HttpStatus.FORBIDDEN,
      {
        ...context,
        expectedIp,
        actualIp,
      }
    );
  }
}

/**
 * Exception thrown when user agent doesn't match token
 * 
 * This occurs when user agent binding is enabled and the
 * request comes from a different user agent than expected.
 */
export class CsrfUserAgentMismatchException extends CsrfException {
  constructor(
    expectedUserAgent: string,
    actualUserAgent: string,
    context?: Record<string, unknown>
  ) {
    super(
      'Request User-Agent does not match the token. This may indicate session hijacking.',
      CsrfValidationErrorCode.USER_AGENT_MISMATCH,
      HttpStatus.FORBIDDEN,
      {
        ...context,
        expectedUserAgent: expectedUserAgent.substring(0, 100), // Truncate for security
        actualUserAgent: actualUserAgent.substring(0, 100),
      }
    );
  }
}

/**
 * Exception factory for creating CSRF exceptions based on error codes
 * 
 * Provides a centralized way to create appropriate exception instances
 * based on validation error codes.
 */
export class CsrfExceptionFactory {
  /**
   * Creates a CSRF exception based on the error code
   * 
   * @param errorCode - The specific CSRF validation error code
   * @param context - Additional context for the error
   * @returns Appropriate CSRF exception instance
   */
  public static createFromErrorCode(
    errorCode: CsrfValidationErrorCode,
    context?: Record<string, unknown>
  ): CsrfException {
    switch (errorCode) {
      case CsrfValidationErrorCode.TOKEN_MISSING:
        return new CsrfTokenMissingException(context);
      
      case CsrfValidationErrorCode.TOKEN_MALFORMED:
        return new CsrfTokenMalformedException(context);
      
      case CsrfValidationErrorCode.TOKEN_EXPIRED:
        return new CsrfTokenExpiredException(undefined, context);
      
      case CsrfValidationErrorCode.TOKEN_INVALID_SIGNATURE:
        return new CsrfTokenInvalidSignatureException(context);
      
      case CsrfValidationErrorCode.SESSION_MISMATCH:
        return new CsrfSessionMismatchException(
          context?.expectedSessionId as string || 'unknown',
          context?.actualSessionId as string || 'unknown',
          context
        );
      
      case CsrfValidationErrorCode.ORIGIN_FORBIDDEN:
        return new CsrfOriginForbiddenException(
          context?.origin as string || 'unknown',
          (context?.allowedOrigins as string[]) || [],
          context
        );
      
      case CsrfValidationErrorCode.REPLAY_ATTACK_DETECTED:
        return new CsrfReplayAttackException(
          context?.tokenIdentifier as string,
          context
        );
      
      case CsrfValidationErrorCode.IP_ADDRESS_MISMATCH:
        return new CsrfIpAddressMismatchException(
          context?.expectedIp as string || 'unknown',
          context?.actualIp as string || 'unknown',
          context
        );
      
      case CsrfValidationErrorCode.USER_AGENT_MISMATCH:
        return new CsrfUserAgentMismatchException(
          context?.expectedUserAgent as string || 'unknown',
          context?.actualUserAgent as string || 'unknown',
          context
        );
      
      default:
        return new CsrfTokenMalformedException({
          ...context,
          unknownErrorCode: errorCode,
        });
    }
  }
}

/**
 * Type-safe error handler for CSRF operations
 * 
 * Provides utility functions for handling and transforming
 * CSRF-related errors in a consistent manner.
 */
export class CsrfErrorHandler {
  /**
   * Handles an error and converts it to an appropriate CSRF exception
   * 
   * @param error - The error to handle
   * @param context - Additional context for error handling
   * @returns CSRF exception or re-throws if not CSRF-related
   */
  public static handleError(
    error: unknown,
    context?: Record<string, unknown>
  ): never {
    // If it's already a CSRF exception, re-throw it
    if (error instanceof CsrfException) {
      throw error;
    }

    // If it's a standard Error, wrap it appropriately
    if (error instanceof Error) {
      // Check error message patterns for specific error types
      if (error.message.includes('expired')) {
        throw new CsrfTokenExpiredException(undefined, {
          ...context,
          originalError: error.message,
        });
      }
      
      if (error.message.includes('malformed') || error.message.includes('decrypt')) {
        throw new CsrfTokenMalformedException({
          ...context,
          originalError: error.message,
        });
      }
      
      if (error.message.includes('signature')) {
        throw new CsrfTokenInvalidSignatureException({
          ...context,
          originalError: error.message,
        });
      }
    }

    // Default to malformed token exception for unknown errors
    throw new CsrfTokenMalformedException({
      ...context,
      originalError: String(error),
    });
  }

  /**
   * Safely extracts error information for logging
   * 
   * @param error - The error to extract information from
   * @returns Safe error information object
   */
  public static extractErrorInfo(error: unknown): {
    message: string;
    code?: CsrfValidationErrorCode;
    stack?: string;
  } {
    if (error instanceof CsrfException) {
      return {
        message: error.message,
        code: error.errorCode,
        stack: error.stack,
      };
    }

    if (error instanceof Error) {
      return {
        message: error.message,
        stack: error.stack,
      };
    }

    return {
      message: String(error),
    };
  }

  /**
   * Handles guard-specific errors and returns appropriate boolean response
   * 
   * This method is designed for use in guards where throwing exceptions
   * might not be appropriate and a boolean response is needed.
   * 
   * @param error - The error that occurred
   * @returns false for security by default
   */
  public static handleGuardError(error: unknown): boolean {
    // Log the error but don't throw in guard context
    console.error('CSRF Guard Error:', this.extractErrorInfo(error));
    
    // Return false for security - deny access when errors occur
    return false;
  }
}